## 前言:

### why  

- 1.困惑：

> 1.mutable state(可变状态)  
> 2.unrestricted side effects(无限制副作用)  
> 3.unprincipled design（无原则设计）  

- 2.规则：

> 1.DRY（don't repeat yourself）(不要重复你自己)  
> 2.LCHC（loose coupling high cohesion）（高内聚、低耦合）  
> 3.YAGNI（you aren't gonna need it）(你不会用到它的)  
> 4.POLS(Principle of least surprise)(最小意外原则)  
> 5.SR(single responsibility)(单一原则)

- 3.定义：

> [范畴论](https://baike.baidu.com/item/%E8%8C%83%E7%95%B4%E8%AE%BA/8281114?fr=aladdin)(需要注意是【函子】)->一整套函数的运算方法->最开始用于数学计算->后来在计算机编程实现(函数式编程)

## 1.一等公民

- 1.使用一个函数把另外一个函数包裹起来，仅仅是为了延迟执行函数，是个糟糕的编程习惯

````
// 太傻了
var getServerStuff = function(callback){
  return ajaxCall(function(json){
    return callback(json);
  });
};

// 这才像样
var getServerStuff = ajaxCall;
````

> 1.1.提高维护成本、以及增加检索  
> 1.2.函数变动，包裹函数也要发生变化  

````
// bad
httpGet('/post/2', function(json){
  return renderPost(json);
});
httpGet('/post/2', function(json, err){
  return renderPost(json, err);
});
// good
httpGet('/post/2', renderPost);
```` 
- 1.3.命名,通用代码使用通用规则,业务代码使用业务命名  

````
// 只针对当前的博客
var validArticles = function(articles) {
  return articles.filter(function(article){
    return article !== null && article !== undefined;
  });
};

// 对未来的项目友好太多
var compact = function(xs) {
  return xs.filter(function(x) {
    return x !== null && x !== undefined;
  });
};
````

- 1.4.避免使用this  

````
// 好一些 
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
````

- 1.4.1.箭头函数中最好不使用this

````
$('pay-btn').on('click', () => {
	let $this = $(this);
	console.log('this document element was: ', $this[0]);
});
````

- 1.4.2.vue中使用this的话，建议如下

````
init() {
	let self = this;
	self.loadList().then(resp => {
		return resp.data || [];
	})
	.then(datas => {
		self.datas = datas;
		return null;
	})
	.then(() => {
		setTimeout(() => {
			// 此处的self是vue中的this，指向创建的vue对象本身
			self.lazyLoadImages();			
		}, 0);
	});
},
lazyLoadImages() {
	// 图片懒加载
}
````

- 1.4.2.1.【QS】vue中this总是指向vue创建的对象本身，这个是怎么实现的?


## 2.纯函数

- 定义: 不改变输入值(如果值是地址引用的话)

````
var arr = [13, 12, 33, 44];
// start: 下标, end: 第几个(下标+1)
// 纯函数
arr.slice(0, 1); 
// start: 下标, howmany: 多少个
// 函数不纯,改变了arr
arr.splice(3, 1); 
````

- 定义：不依赖外部变量

````
// 不纯的
var minimum = 21;
var checkAge = function(age) {
  return age >= minimum;
};

// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
````

> [依赖是增加系统复杂度的罪魁祸首](http://curtclifton.net/papers/MoseleyMarks06a.pdf)


- 副作用：计算过程中，系统状态一种变化/与外界进行可观察的交互

> 1.尽量避免副作用的（后面可以使用functor，monad使之可控，如果不可避免）解释：  
> 死水中的水不是滋生病菌的培养器，”死“才是原因。副作用的“副”是滋生bug的温床

- 原则: `「相同输入得到相同输出」`

````
// TODO
````

> 1.纯函数是数学上的函数,是函数式编程的全部

- 推荐理由: 

> 1. 可缓存(cacheable)  

````
// 缓存函数,而非其结果
var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};
var squareNumber  = memoize(function(x){ return x*x; });
squareNumber(4);
````

> 2. 可移植性／自文档化（Portable / Self-Documenting） 

````
// 纯的:参数指明当前函数依赖
var signUp = function(Db, Email, attrs) {
  return function() {
    var user = saveUser(Db, attrs);
    welcomeUser(Email, user);
  };
};

var saveUser = function(Db, attrs) {
    ...
};

var welcomeUser = function(Email, user) {
    ...
};
````

> 3. 可测试性（Testable）： [quick check](https://en.wikipedia.org/wiki/QuickCheck) /[quick check(jianshu)](http://www.jianshu.com/p/bb93972bac53)
> 4. 并行执行代码: 纯函数不需要访问共享内存,不会因为副作用进入[竞态(race condition)](https://en.wikipedia.org/wiki/Race_condition)/[竞态(csdn)](http://blog.csdn.net/silentpebble/article/details/6900162)

## 3.[柯里化(curry)](https://baike.baidu.com/item/%E6%9F%AF%E9%87%8C%E5%8C%96/10350525?fr=aladdin)

- 前言: 有些事物你得到之前无足轻重，得到之后就变得不可或缺。

- 概念: 只给函数一部分参数来调用它,让它返回一个函数处理剩下的参数(把多参数函数转换成单参数函数)

````
// update before
var add = function(x, y){
	return x + y;
}
add(12, 13);
// update after
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);
increment(2);
addTen(2);
// or use like this
add(1)(2)

````

- 实际运用

````
var curry = require('lodash').curry;

var match = curry(function(what, str) {
  return str.match(what);
});
match(/\s+/g, "hello world");
````

- curry实现

````
// 第一版
var curry = function (fn) {
    var args = [].slice.call(arguments, 1);
    return function() {
        var newArgs = args.concat([].slice.call(arguments));
        return fn.apply(this, newArgs);
    };
};
````

- 帮助curry的库: [ramda](https://github.com/ramda/ramda),[loadash-fp](https://github.com/lodash-archive/lodash-fp)

> 1.ramda和underscore、loadash的区别是参数位置不一样  
> 2.ramda推崇的理念: function first, data last

- [curry的用处(张鑫旭)](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)

> 1.参数复用  

````
// 下为官员如何搞定7个老婆的测试
// 获得合法老婆
var getWife = currying(function() {
    var allWife = [].slice.call(arguments);
    // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆
    console.log(allWife.join(";"));
}, "合法老婆");

// 获得其他6个老婆
getWife("大老婆","小老婆","俏老婆","刁蛮老婆","乖老婆","送上门老婆");

// 换一批老婆
getWife("超越韦小宝的老婆");
````

> 2.提前返回  

````
var addEvent = (function(){
    if (window.addEventListener) {
        return function(el, sType, fn, capture) {
            el.addEventListener(sType, function(e) {
                fn.call(el, e);
            }, (capture));
        };
    } else if (window.attachEvent) {
        return function(el, sType, fn, capture) {
            el.attachEvent("on" + sType, function(e) {
                fn.call(el, e);
            });
        };
    }
})();
````

> 3.延迟执行/运算  

````
var curryWeight = function(fn) {
    var _fishWeight = [];
    return function() {
        if (arguments.length === 0) {
        	// 最终执行函数 
            return fn.apply(null, _fishWeight);
        } else {
        	// 只是累加参数
            _fishWeight = _fishWeight.concat([].slice.call(arguments));
        }
    }
};
var fishWeight = 0;
var addWeight = curryWeight(function() {
    var i=0; len = arguments.length;
    for (i; i<len; i+=1) {
        fishWeight += arguments[i];
    }
});

addWeight(2.3);
addWeight(6.5);
addWeight(1.2);
addWeight(2.5);
addWeight();    //  这里才计算

console.log(fishWeight);    // 12.5
````


## 4.代码组合(compose)

- 普通的函数组合

````
var compose = function(f,g) {
  return function(x) {
    return f(g(x));
  };
};
// 变大写
var toUpperCase = function(x) { return x.toUpperCase(); };
// 最后加一个感叹号
var exclaim = function(x) { return x + '!'; };
var shout = compose(exclaim, toUpperCase);

shout("send in the clowns");
````


## 5.示例应用

## 6.Hindley-Milner类型签名

## 7.特百惠

## 8.Monad

## 9.Applicative functor

## ps：参考资料

- [gitbook](https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
- [JavaScript专题之柯里化(segmentfault)](https://segmentfault.com/a/1190000010608477)
- [reduce和transduce的含义(阮一峰)](http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html)
- [ramda函数库参考教程(阮一峰)](http://www.ruanyifeng.com/blog/2017/03/ramda.html)
- [函数式编程入门(阮一峰)](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)