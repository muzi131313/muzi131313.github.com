## 前言:

### why  

- 1.困惑：

> 1.mutable state(可变状态)  
> 2.unrestricted side effects(无限制副作用)  
> 3.unprincipled design（无原则设计）  

- 2.规则：

> 1.DRY（don't repeat yourself）(不要重复你自己)  
> 2.LCHC（loose coupling high cohesion）（高内聚、低耦合）  
> 3.YAGNI（you aren't gonna need it）(你不会用到它的)  
> 4.POLS(Principle of least surprise)(最小意外原则)  
> 5.SR(single responsibility)(单一原则)

- 3.定义：

> [范畴论](https://baike.baidu.com/item/%E8%8C%83%E7%95%B4%E8%AE%BA/8281114?fr=aladdin)->一整套函数的运算方法->最开始用于数学计算->后来在计算机编程实现(函数式编程)

## 1.一等公民

- 1.使用一个函数把另外一个函数包裹起来，仅仅是为了延迟执行函数，是个糟糕的编程习惯

````
// 太傻了
var getServerStuff = function(callback){
  return ajaxCall(function(json){
    return callback(json);
  });
};

// 这才像样
var getServerStuff = ajaxCall;
````

> 1.1.提高维护成本、以及增加检索  
> 1.2.函数变动，包裹函数也要发生变化  

````
// bad
httpGet('/post/2', function(json){
  return renderPost(json);
});
httpGet('/post/2', function(json, err){
  return renderPost(json, err);
});
// good
httpGet('/post/2', renderPost);
```` 
- 1.3.命名,通用代码使用通用规则,业务代码使用业务命名  

````
// 只针对当前的博客
var validArticles = function(articles) {
  return articles.filter(function(article){
    return article !== null && article !== undefined;
  });
};

// 对未来的项目友好太多
var compact = function(xs) {
  return xs.filter(function(x) {
    return x !== null && x !== undefined;
  });
};
````

- 1.4.避免使用this  

````
// 好一些 
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
````

- 1.4.1.箭头函数中最好不使用this

````
$('pay-btn').on('click', () => {
	let $this = $(this);
	console.log('this document element was: ', $this[0]);
});
````

- 1.4.2.vue中使用this的话，建议如下

````
init() {
	let self = this;
	self.loadList().then(resp => {
		return resp.data || [];
	})
	.then(datas => {
		self.datas = datas;
		return null;
	})
	.then(() => {
		setTimeout(() => {
			// 此处的self是vue中的this，指向创建的vue对象本身
			self.lazyLoadImages();			
		}, 0);
	});
},
lazyLoadImages() {
	// 图片懒加载
}
````


## 2.纯函数

- 定义: 不改变输入值(如果值是地址引用的话)

````
var arr = [13, 12, 33, 44];
// start: 下标, end: 第几个(下标+1)
// 纯函数
arr.slice(0, 1); 
// start: 下标, howmany: 多少个
// 函数不纯,改变了arr
arr.splice(3, 1); 
````

- 定义：不依赖外部变量

````
// 不纯的
var minimum = 21;
var checkAge = function(age) {
  return age >= minimum;
};

// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
````

> [依赖是增加系统复杂度的罪魁祸首](http://curtclifton.net/papers/MoseleyMarks06a.pdf)


- 副作用：计算过程中，系统状态一种变化/与外界进行可观察的交互

> 1.尽量避免副作用的（后面可以使用functor，monad使之可控，如果不可避免）解释：  
> 死水中的水不是滋生病菌的培养器，”死“才是原因。副作用的“副”是滋生bug的温床

- 原则: `「相同输入得到相同输出」`

````
````

- 推荐理由: 

> 1. 可缓存(cacheable)  

````
// 缓存函数,而非其结果
var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};
var squareNumber  = memoize(function(x){ return x*x; });
squareNumber(4);
````

> 2. 可移植性／自文档化（Portable / Self-Documenting） 

````
// TODO:
````

> 3. 可测试性（Testable）  
> 4. 并行代码: 纯函数不需要访问共享内存  

## 3.柯里化(curry)

- 概念: 只给函数一部分参数来调用它,让它返回一个函数处理剩下的参数(把多参数函数转换成单参数函数)

````
// update before
var add = function(x, y){
	return x + y;
}
add(12, 13);
// update after
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);
increment(2);
addTen(2);
// or use like this
add(1)(2)

````

- 实际运用

````
var curry = require('lodash').curry;

var match = curry(function(what, str) {
  return str.match(what);
});
match(/\s+/g, "hello world");
````

- curry实现

````
// 第一版
var curry = function (fn) {
    var args = [].slice.call(arguments, 1);
    return function() {
        var newArgs = args.concat([].slice.call(arguments));
        return fn.apply(this, newArgs);
    };
};
````

- 帮助curry的库: [ramda](https://github.com/ramda/ramda),[loadash-fp](https://github.com/lodash-archive/lodash-fp)

> 1.ramda和underscore、loadash的区别是参数位置不一样  
> 2.ramda推崇的理念: function first, data last


## 4.代码组合(compose)

- 

## 5.示例应用

## 6.Hindley-Milner类型签名

## 7.特百惠

## 8.Monad

## 9.Applicative functor

## ps：参考资料

- [gitbook](https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
- [JavaScript专题之柯里化(segmentfault)](https://segmentfault.com/a/1190000010608477)
- [reduce和transduce的含义(阮一峰)](http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html)
- [ramda函数库参考教程(阮一峰)](http://www.ruanyifeng.com/blog/2017/03/ramda.html)
- [函数式编程入门(阮一峰)](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)